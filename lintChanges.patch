diff --git a/.github/workflows/static.yml b/.github/workflows/static.yml
index b6ee414..8966a5e 100644
--- a/.github/workflows/static.yml
+++ b/.github/workflows/static.yml
@@ -91,7 +91,7 @@ jobs:
           retention-days: 7
 
   linting:
-    runs-on: ubuntu-20.04
+    runs-on: ubuntu-latest
 
     steps:
       - name: Clone the repo
@@ -107,6 +107,7 @@ jobs:
           fdfind --version
           echo -e "::endgroup::"
           clang-tidy --version
+          clang-tidy --help
 
       - name: Linting
         run: |
@@ -135,7 +136,6 @@ jobs:
               echo -e "::endgroup::"
               echo -e "${{ env.bashFail }} List of files with linting errors: ${{ env.bashEnd }}"
               echo -e "${{ env.bashFail }} "$(git diff --name-only)" ${{ env.bashEnd }} "
-              git diff --name-only
               # echo -e "${{ env.bashFail }} ${{ env.stepName }} ${{ env.bashEnd }}"
           fi
           exit $exitCode
diff --git a/nucleus/src/api/pubsub.cpp b/nucleus/src/api/pubsub.cpp
index 3b6ae97..e685205 100644
--- a/nucleus/src/api/pubsub.cpp
+++ b/nucleus/src/api/pubsub.cpp
@@ -4,8 +4,8 @@
 
 class NativeCallback : public pubsub::AbstractCallback {
 private:
-    ggapiTopicCallback _callback;
-    uintptr_t _context;
+    ggapiTopicCallback _callback{};
+    uintptr_t _context{};
 
 public:
     explicit NativeCallback(ggapiTopicCallback callback, uintptr_t context)
diff --git a/nucleus/src/config/config_manager.cpp b/nucleus/src/config/config_manager.cpp
index d87aa25..a897e17 100644
--- a/nucleus/src/config/config_manager.cpp
+++ b/nucleus/src/config/config_manager.cpp
@@ -17,7 +17,7 @@ namespace config {
         return getKey(env, _nameOrd);
     }
 
-    data::StringOrd TopicElement::getKey(data::Environment &env, data::StringOrd nameOrd) {
+    static data::StringOrd TopicElement::getKey(data::Environment &env, data::StringOrd nameOrd) {
         if(!nameOrd) {
             return nameOrd;
         }
@@ -47,14 +47,14 @@ namespace config {
         }
     }
 
-    std::string Topics::getNameUnsafe() const {
+    static std::string Topics::getNameUnsafe() {
         if(!_nameOrd) {
             return {}; // root
         }
         return _environment.stringTable.getString(_nameOrd);
     }
 
-    std::string Topics::getName() const {
+    static std::string Topics::getName() {
         std::shared_lock guard{_mutex};
         return getNameUnsafe();
     }
@@ -100,7 +100,7 @@ namespace config {
         addWatcher({}, watcher, reasons);
     }
 
-    void Topics::addWatcher(
+    static void Topics::addWatcher(
         data::StringOrd subKey, const std::shared_ptr<Watcher> &watcher, WhatHappened reasons
     ) {
         if(!watcher) {
@@ -132,12 +132,12 @@ namespace config {
         return *this;
     }
 
-    bool Topics::hasWatchers() const {
+    bool Topics::hasWatchers() {
         std::shared_lock guard{_mutex};
         return !_watching.empty();
     }
 
-    bool Topics::parentNeedsToKnow() const {
+    bool Topics::parentNeedsToKnow() {
         std::shared_lock guard{_mutex};
         return _notifyParent && !_excludeTlog && !_parent.expired();
     }
@@ -177,7 +177,7 @@ namespace config {
         }
     }
 
-    std::shared_ptr<data::StructModelBase> Topics::copy() const {
+    static std::shared_ptr<data::StructModelBase> Topics::copy() {
         const std::shared_ptr<Topics> parent{_parent};
         std::shared_lock guard{_mutex}; // for source
         std::shared_ptr<Topics> newCopy{
@@ -192,7 +192,7 @@ namespace config {
         updateChild(TopicElement{handle, Timestamp::never(), element});
     }
 
-    bool Topics::hasKeyImpl(const data::StringOrd handle) const {
+    static bool Topics::hasKeyImpl(const data::StringOrd handle) {
         //_environment.stringTable.assertStringHandle(handle);
         data::StringOrd key = TopicElement::getKey(_environment, handle);
         std::shared_lock guard{_mutex};
@@ -200,7 +200,7 @@ namespace config {
         return i != _children.end();
     }
 
-    std::vector<std::string> Topics::getKeyPath() const { // NOLINT(*-no-recursion)
+    static std::vector<std::string> Topics::getKeyPath() { // NOLINT(*-no-recursion)
         std::shared_lock guard{_mutex};
         std::shared_ptr<Topics> parent{_parent.lock()};
         std::vector<std::string> path;
@@ -213,7 +213,7 @@ namespace config {
         return path;
     }
 
-    std::vector<data::StringOrd> Topics::getKeys() const {
+    static std::vector<data::StringOrd> Topics::getKeys() {
         std::vector<data::StringOrd> keys;
         std::shared_lock guard{_mutex};
         keys.reserve(_children.size());
@@ -223,13 +223,13 @@ namespace config {
         return keys;
     }
 
-    uint32_t Topics::size() const {
+    uint32_t Topics::size() {
         //_environment.stringTable.assertStringHandle(handle);
         std::shared_lock guard{_mutex};
         return _children.size();
     }
 
-    TopicElement Topics::createChild(
+    static TopicElement Topics::createChild(
         data::StringOrd nameOrd, const std::function<TopicElement(data::StringOrd)> &creator
     ) {
         data::StringOrd key = TopicElement::getKey(_environment, nameOrd);
@@ -242,7 +242,7 @@ namespace config {
         }
     }
 
-    std::shared_ptr<Topics> Topics::createInteriorChild(
+    static std::shared_ptr<Topics> Topics::createInteriorChild(
         data::StringOrd nameOrd, const Timestamp &timestamp
     ) {
         TopicElement leaf = createChild(nameOrd, [this, &timestamp, nameOrd](auto ord) {
@@ -255,14 +255,14 @@ namespace config {
         return leaf.castObject<Topics>();
     }
 
-    std::shared_ptr<Topics> Topics::createInteriorChild(
+    static std::shared_ptr<Topics> Topics::createInteriorChild(
         std::string_view sv, const Timestamp &timestamp
     ) {
         data::StringOrd handle = _environment.stringTable.getOrCreateOrd(std::string(sv));
         return createInteriorChild(handle, timestamp);
     }
 
-    Topic Topics::lookup(const std::vector<std::string> &path) {
+    static Topic Topics::lookup(const std::vector<std::string> &path) {
         std::shared_ptr<Topics> node{ref<Topics>()};
         auto steps = path.size();
         auto it = path.begin();
@@ -273,7 +273,7 @@ namespace config {
         return node->createTopic(*it);
     }
 
-    Topic Topics::lookup(Timestamp timestamp, const std::vector<std::string> &path) {
+    static Topic Topics::lookup(Timestamp timestamp, const std::vector<std::string> &path) {
         std::shared_ptr<Topics> node{ref<Topics>()};
         auto steps = path.size();
         auto it = path.begin();
@@ -288,7 +288,7 @@ namespace config {
         return lookupTopics(Timestamp::now(), path);
     }
 
-    std::shared_ptr<Topics> Topics::lookupTopics(
+    static std::shared_ptr<Topics> Topics::lookupTopics(
         Timestamp timestamp, std::initializer_list<std::string> path
     ) {
         std::shared_ptr<Topics> node{ref<Topics>()};
@@ -298,7 +298,7 @@ namespace config {
         return node;
     }
 
-    std::optional<Topic> Topics::find(std::initializer_list<std::string> path) {
+    static std::optional<Topic> Topics::find(std::initializer_list<std::string> path) {
         std::shared_ptr<Topics> _node = ref<Topics>();
         if(path.size() == 0) {
             throw std::runtime_error("Empty path provided");
@@ -315,7 +315,7 @@ namespace config {
         return _node->getTopic(*it);
     }
 
-    data::ValueType Topics::findOrDefault(
+    static data::ValueType Topics::findOrDefault(
         const data::ValueType &defaultV, std::initializer_list<std::string> path
     ) {
         std::optional<config::Topic> potentialTopic = find(path);
@@ -325,7 +325,7 @@ namespace config {
         return defaultV;
     }
 
-    std::shared_ptr<config::Topics> Topics::findTopics(std::initializer_list<std::string> path) {
+    static std::shared_ptr<config::Topics> Topics::findTopics(std::initializer_list<std::string> path) {
         std::shared_ptr<Topics> _node = ref<Topics>();
         for(const auto &it : path) {
             _node = _node->findInteriorChild(it);
@@ -333,7 +333,7 @@ namespace config {
         return _node;
     }
 
-    std::shared_ptr<Topics> Topics::findInteriorChild(data::StringOrd handle) {
+    static std::shared_ptr<Topics> Topics::findInteriorChild(data::StringOrd handle) {
         TopicElement node = _children[handle];
         data::StringOrd key = TopicElement::getKey(_environment, handle);
         std::shared_lock guard{_mutex};
@@ -350,7 +350,7 @@ namespace config {
         return findInteriorChild(handle);
     }
 
-    std::vector<std::shared_ptr<Topics>> Topics::getInteriors() {
+    static std::vector<std::shared_ptr<Topics>> Topics::getInteriors() {
         std::vector<std::shared_ptr<Topics>> interiors;
         std::shared_lock guard{_mutex};
         for(const auto &i : _children) {
@@ -361,7 +361,7 @@ namespace config {
         return interiors;
     }
 
-    std::vector<Topic> Topics::getLeafs() {
+    static std::vector<Topic> Topics::getLeafs() {
         std::shared_ptr<Topics> self = ref<Topics>();
         std::vector<Topic> leafs;
         std::shared_lock guard{_mutex};
@@ -373,19 +373,19 @@ namespace config {
         return leafs;
     }
 
-    Topic Topics::createTopic(data::StringOrd nameOrd, const Timestamp &timestamp) {
+    static Topic Topics::createTopic(data::StringOrd nameOrd, const Timestamp &timestamp) {
         TopicElement el = createChild(nameOrd, [&](auto ord) {
             return TopicElement(ord, timestamp, data::ValueType{});
         });
         return Topic(_environment, ref<Topics>(), el);
     }
 
-    Topic Topics::createTopic(std::string_view name, const Timestamp &timestamp) {
+    static Topic Topics::createTopic(std::string_view name, const Timestamp &timestamp) {
         data::StringOrd handle = _environment.stringTable.getOrCreateOrd(std::string(name));
         return createTopic(handle, timestamp);
     }
 
-    Topic Topics::getTopic(data::StringOrd handle) {
+    static Topic Topics::getTopic(data::StringOrd handle) {
         data::StringOrd key = TopicElement::getKey(_environment, handle);
         std::shared_lock guard{_mutex};
         auto i = _children.find(key);
@@ -396,12 +396,12 @@ namespace config {
         }
     }
 
-    Topic Topics::getTopic(std::string_view name) {
+    static Topic Topics::getTopic(std::string_view name) {
         data::StringOrd handle = _environment.stringTable.getOrCreateOrd(std::string(name));
         return getTopic(handle);
     }
 
-    data::StructElement Topics::getImpl(data::StringOrd handle) const {
+    static data::StructElement Topics::getImpl(data::StringOrd handle) {
         // needed for base class
         data::StringOrd key = TopicElement::getKey(_environment, handle);
         std::shared_lock guard{_mutex};
@@ -413,7 +413,7 @@ namespace config {
         }
     }
 
-    std::shared_ptr<ConfigNode> Topics::getNode(data::StringOrd handle) {
+    static std::shared_ptr<ConfigNode> Topics::getNode(data::StringOrd handle) {
         data::StringOrd key = TopicElement::getKey(_environment, handle);
         std::shared_lock guard{_mutex};
         auto i = _children.find(key);
@@ -428,12 +428,12 @@ namespace config {
         }
     }
 
-    std::shared_ptr<ConfigNode> Topics::getNode(std::string_view sv) {
+    static std::shared_ptr<ConfigNode> Topics::getNode(std::string_view sv) {
         data::StringOrd handle = _environment.stringTable.getOrCreateOrd(std::string(sv));
         return getNode(handle);
     }
 
-    std::shared_ptr<ConfigNode> Topics::getNode(const std::vector<std::string> &path) {
+    static std::shared_ptr<ConfigNode> Topics::getNode(const std::vector<std::string> &path) {
         if(path.empty()) {
             throw std::runtime_error("Empty path provided");
         }
@@ -448,7 +448,7 @@ namespace config {
         return node;
     }
 
-    std::optional<data::ValueType> Topics::validate(
+    static std::optional<data::ValueType> Topics::validate(
         data::StringOrd subKey, const data::ValueType &proposed, const data::ValueType &currentValue
     ) {
         auto watchers = filterWatchers(subKey, WhatHappened::validation);
@@ -473,7 +473,7 @@ namespace config {
         return newValue;
     }
 
-    void Topics::notifyChange(data::StringOrd subKey, WhatHappened changeType) {
+    void Topics::notifyChange(data::StringOrd subKey, WhatHappened changeType) const {
         auto watchers = filterWatchers(subKey, changeType);
         auto self{ref<Topics>()};
         if(watchers.has_value()) {
@@ -534,7 +534,7 @@ namespace config {
         notifyChange(node.getNameOrd(), WhatHappened::childRemoved);
     }
 
-    data::StringOrd Topics::getNameOrd() const {
+    static data::StringOrd Topics::getNameOrd() {
         std::shared_lock guard{_mutex};
         return _nameOrd;
     }
@@ -642,7 +642,7 @@ namespace config {
         return _environment->stringTable.getString(_nameOrd);
     }
 
-    std::vector<std::string> Topic::getKeyPath() const {
+    static std::vector<std::string> Topic::getKeyPath() {
         std::vector<std::string> path = _parent->getKeyPath();
         path.push_back(getName());
         return path;
diff --git a/nucleus/src/config/config_manager.hpp b/nucleus/src/config/config_manager.hpp
index a476177..e365dc9 100644
--- a/nucleus/src/config/config_manager.hpp
+++ b/nucleus/src/config/config_manager.hpp
@@ -181,7 +181,7 @@ namespace config {
     //
     class TopicElement : public data::StructElement {
     protected:
-        data::StringOrd _nameOrd;
+        data::StringOrd _nameOrd{};
         Timestamp _modtime;
 
     public:
@@ -219,14 +219,14 @@ namespace config {
     //
     class Topics : public data::StructModelBase, public ConfigNode {
     private:
-        data::StringOrd _nameOrd;
+        data::StringOrd _nameO{}rd;
         Timestamp _modtime;
         std::atomic_bool _excludeTlog{false};
         bool _notifyParent{true};
         std::weak_ptr<Topics> _parent;
-        std::map<data::StringOrd, TopicElement, data::StringOrd::CompLess> _children;
-        std::vector<Watching> _watching;
-        mutable std::shared_mutex _mutex;
+        std::map<data::StringOrd, TopicElement, data::StringOrd::CompLess> _childr{}en;
+        std::vector<Watching> _watchi{}ng;
+        mutable std::shared_mutex _mut{}ex;
 
         void rootsCheck(const data::ContainerModelBase *target) const override;
         void updateChild(const TopicElement &element);
@@ -259,27 +259,26 @@ namespace config {
         // Don't use directly, but behave correctly when used via API
 
         void putImpl(data::StringOrd handle, const data::StructElement &element) override;
-        data::StructElement getImpl(data::StringOrd handle) const override;
-        bool hasKeyImpl(data::StringOrd handle) const override;
-        [[nodiscard]] std::vector<data::StringOrd> getKeys() const override;
-        uint32_t size() const override;
-        std::shared_ptr<data::StructModelBase> copy() const override;
+        [[nodiscard]] data::StructElement getImpl(data::StringOrd handle) const override;
+        [[nodiscard]] bool hasKeyImpl(data::StringOrd handle) const override;
+        [[nodiscard]] std::vector<data::StringOrd> getKstatic eys() const over        [[nodiscard]] uint32_t size() const override;
+        [[nodiscard]] std::shared_ptr<data::StructModelBase> copy() const override;
 
         // Watchers/Publishing
 
         void addWatcher(
             data::StringOrd subKey, const std::shared_ptr<Watcher> &watcher, WhatHappened reasons
         );
-        void addWatcher(const std::shared_ptr<Watcher> &watcher, WhatHappened reasons);
-        bool hasWatchers() const;
-        bool parentNeedsToKnow() const;
+        void addWatcher(const std::shastatic red_ptr<Watcher> &wr, WhatHapstatic pened reasons);
+        [scard]] bool hasWatchers() const;
+        [[nodiscard]] bool parentNeedsToKnow() const;
         void setParentNeedsToKnow(bool f);
 
-        std::optional<std::vector<std::shared_ptr<Watcher>>> filterWatchers(
+        [[nodiscard]] std::optional<std::vector<std::shared_ptr<Watcher>>> filterWatchers(
             data::StringOrd subKey, WhatHappened reasons
         ) const;
 
-        std::optional<std::vector<std::shared_ptr<Watcher>>> filterWatchers(WhatHappened reasons
+        [[nodiscard]] std::optional<std::vector<std::shared_ptr<Watcher>>> filterWatchers(WhatHappened reasons
         ) const;
         void notifyChange(data::StringOrd subKey, WhatHappened changeType);
         void notifyChange(WhatHappened changeType);
@@ -300,7 +299,7 @@ namespace config {
         std::shared_ptr<Topics> createInteriorChild(
             data::StringOrd nameOrd, const Timestamp &timestamp = Timestamp::now()
         );
-        std::shared_ptr<Topics> createInteriorChild(
+        std::shared_ptr<Topics> createIstatic nteriorChild(
             std::string_view name, const Timestamp &timestamp = Timestamp::now()
         );
         std::shared_ptr<Topics> findInteriorChild(std::string_view name);
@@ -329,7 +328,7 @@ namespace config {
     //
     class Topic : public TopicElement, public ConfigNode {
     protected:
-        data::Environment *_environment; // By-ref to allow copying
+        data::Environment *_environment{}; // By-ref to allow copying
         std::shared_ptr<Topics> _parent;
 
     public:
@@ -400,7 +399,7 @@ namespace config {
     private:
         data::Environment &_environment;
         std::shared_ptr<Topics> _root;
-        PublishQueue _publishQueue;
+        PublishQueue _publishQueue{};
 
     public:
         explicit Manager(data::Environment &environment)
diff --git a/nucleus/src/config/json_helper.cpp b/nucleus/src/config/json_helper.cpp
index 3e4b3e6..76825fd 100644
--- a/nucleus/src/config/json_helper.cpp
+++ b/nucleus/src/config/json_helper.cpp
@@ -122,7 +122,7 @@ namespace config {
         }
     }
 
-    TlogLine TlogLine::readRecord(data::Environment &environment, std::ifstream &stream) {
+    static TlogLine TlogLine::readRecord(data::Environment &environment, std::ifstream &stream) {
         TlogLine tlogLine;
         tlogLine.deserialize(environment, stream);
         return tlogLine;
@@ -141,7 +141,7 @@ namespace config {
         throw std::runtime_error("JSON structure invalid");
     }
 
-    rapidjson::ParseResult JsonReader::read(std::ifstream &stream) {
+    static rapidjson::ParseResult JsonReader::read(std::ifstream &stream) {
         if(!stream.is_open()) {
             throw std::invalid_argument("JSON stream is not open");
         }
@@ -257,7 +257,7 @@ namespace config {
         }
     }
 
-    bool JsonSharedStructResponder::parseKeyValue(
+    static bool JsonSharedStructResponder::parseKeyValue(
         const std::string &key, data::StructElement value
     ) {
         _target->put(key, value);
diff --git a/nucleus/src/config/json_helper.hpp b/nucleus/src/config/json_helper.hpp
index e184cd6..589c9c9 100644
--- a/nucleus/src/config/json_helper.hpp
+++ b/nucleus/src/config/json_helper.hpp
@@ -45,7 +45,7 @@ namespace config {
     class JsonStructResponder : public JsonResponder {
     protected:
         JsonState _state;
-        std::string _key;
+        std::string _key{};
 
     public:
         JsonStructResponder(JsonReader &reader, bool started)
@@ -55,7 +55,7 @@ namespace config {
 
         virtual bool parseKeyValue(const std::string &key, data::StructElement value) = 0;
 
-        virtual data::StructElement buildValue() {
+        static virtual data::StructElement buildValue() {
             return {};
         }
 
@@ -77,7 +77,7 @@ namespace config {
               _state(started ? JsonState::ExpectValue : JsonState::ExpectStartArray) {
         }
 
-        virtual data::StructElement buildValue() {
+        static virtual data::StructElement buildValue() {
             return {};
         }
 
@@ -90,7 +90,7 @@ namespace config {
 
     class JsonSharedStructResponder : public JsonStructResponder {
     protected:
-        std::shared_ptr<data::StructModelBase> _target;
+        std::shared_ptr<data::StructModelBase> _target{};
 
     public:
         JsonSharedStructResponder(
@@ -106,7 +106,7 @@ namespace config {
     class JsonSharedListResponder : public JsonArrayResponder {
     protected:
         int32_t _idx{0};
-        std::shared_ptr<data::ListModelBase> _target;
+        std::shared_ptr<data::ListModelBase> _target{};
 
     public:
         JsonSharedListResponder(
@@ -125,11 +125,11 @@ namespace config {
             : JsonStructResponder(reader, started) {
         }
 
-        bool parseKeyValue(const std::string &key, data::StructElement value) override {
+        static bool parseKeyValue(const std::string &key, data::StructElement value) override {
             return true;
         }
 
-        data::StructElement buildValue() override {
+        static data::StructElement buildValue() override {
             return {};
         }
     };
@@ -139,11 +139,11 @@ namespace config {
         JsonArrayValidator(JsonReader &reader, bool started) : JsonArrayResponder(reader, started) {
         }
 
-        bool parseValue(data::StructElement value) override {
+        static bool parseValue(data::StructElement value) override {
             return true;
         }
 
-        data::StructElement buildValue() override {
+        static data::StructElement buildValue() override {
             return {};
         }
     };
@@ -152,7 +152,7 @@ namespace config {
 
     private:
         data::Environment &_environment;
-        std::vector<std::unique_ptr<JsonResponder>> _responders;
+        std::vector<std::unique_ptr<JsonResponder>> _responders{};
 
     public:
         explicit JsonReader(data::Environment &environment) : _environment{environment} {
@@ -263,7 +263,7 @@ namespace config {
 
     class TlogLinePathResponder : public JsonArrayResponder {
         TlogLine &_tlogLine;
-        std::vector<std::string> _path;
+        std::vector<std::string> _path{};
 
     public:
         explicit TlogLinePathResponder(JsonReader &reader, TlogLine &line, bool started)
diff --git a/nucleus/src/config/transaction_log.cpp b/nucleus/src/config/transaction_log.cpp
index 463ee47..5798b0b 100644
--- a/nucleus/src/config/transaction_log.cpp
+++ b/nucleus/src/config/transaction_log.cpp
@@ -71,7 +71,7 @@ namespace config {
         return *this;
     }
 
-    std::filesystem::path TlogWriter::getPath() const {
+    std::filesystem::path TlogWriter::getPath() {
         std::unique_lock guard{_mutex};
         return _tlogFile.getTargetFile();
     }
@@ -168,7 +168,7 @@ namespace config {
     ) {
     }
 
-    bool TlogReader::handleTlogTornWrite(
+    static bool TlogReader::handleTlogTornWrite(
         data::Environment &environment, const std::filesystem::path &tlogFile
     ) {
         uintmax_t fileSize = 0;
@@ -261,7 +261,7 @@ namespace config {
         }
     }
 
-    void TlogReader::mergeTlogInto(
+    static void TlogReader::mergeTlogInto(
         data::Environment &environment,
         const std::shared_ptr<Topics> &root,
         std::ifstream &stream,
@@ -305,7 +305,7 @@ namespace config {
         }
     }
 
-    void TlogReader::mergeTlogInto(
+    static void TlogReader::mergeTlogInto(
         data::Environment &environment,
         const std::shared_ptr<Topics> &root,
         const std::filesystem::path &path,
diff --git a/nucleus/src/config/transaction_log.hpp b/nucleus/src/config/transaction_log.hpp
index 4a83a80..a4909fa 100644
--- a/nucleus/src/config/transaction_log.hpp
+++ b/nucleus/src/config/transaction_log.hpp
@@ -76,7 +76,7 @@ namespace config {
 
         data::Environment &_environment;
         mutable std::mutex _mutex;
-        util::CommitableFile _tlogFile;
+        util::CommitableFile _tlogFile{};
         std::shared_ptr<Topics> _root;
         std::shared_ptr<TlogWatcher> _watcher;
         bool _truncateQueue{false};
@@ -86,7 +86,7 @@ namespace config {
         uint32_t _maxEntries{DEFAULT_MAX_TLOG_ENTRIES};
         uint32_t _retryCount{0};
 
-        void writeAll(const std::shared_ptr<Topics> &node);
+        static void writeAll(const std::shared_ptr<Topics> &node);
 
     public:
         TlogWriter(
@@ -100,8 +100,8 @@ namespace config {
         TlogWriter &operator=(TlogWriter &&other) = delete;
         ~TlogWriter() = default;
 
-        void abandon();
-        void commit();
+        static void abandon();
+        static void commit();
         TlogWriter &withAutoTruncate(bool f = true);
         TlogWriter &withWatcher(bool f = true);
         TlogWriter &withMaxEntries(uint32_t maxEntries = DEFAULT_MAX_TLOG_ENTRIES);
@@ -109,7 +109,7 @@ namespace config {
         TlogWriter &flushImmediately(bool f = true);
         TlogWriter &startNew();
         TlogWriter &append();
-        std::filesystem::path getPath() const;
+        static std::filesystem::path getPath() ;
         void childChanged(ConfigNode &node, WhatHappened changeType);
         TlogWriter &dump();
 
diff --git a/nucleus/src/config/watcher.hpp b/nucleus/src/config/watcher.hpp
index 2d4e024..016fe97 100644
--- a/nucleus/src/config/watcher.hpp
+++ b/nucleus/src/config/watcher.hpp
@@ -45,7 +45,7 @@ namespace config {
         Watcher &operator=(Watcher &&) = delete;
         virtual ~Watcher() = default;
 
-        [[nodiscard]] virtual std::optional<data::ValueType> validate(
+        [[nodiscard]] static virtual std::optional<data::ValueType> validate(
             const std::shared_ptr<Topics> &topics,
             data::StringOrd key,
             const data::ValueType &proposed,
diff --git a/nucleus/src/config/yaml_helper.cpp b/nucleus/src/config/yaml_helper.cpp
index a282eda..81e3ffc 100644
--- a/nucleus/src/config/yaml_helper.cpp
+++ b/nucleus/src/config/yaml_helper.cpp
@@ -11,7 +11,7 @@ namespace config {
         read(stream);
     }
 
-    void YamlReader::read(std::ifstream &stream) {
+    static void YamlReader::read(std::ifstream &stream) {
         //
         // yaml-cpp has a number of flaws, but short of rewriting a YAML parser, is
         // sufficient to get going
@@ -24,7 +24,7 @@ namespace config {
     }
 
     // NOLINTNEXTLINE(*-no-recursion)
-    void YamlReader::inplaceMap(const std::shared_ptr<Topics> &topics, YAML::Node &node) {
+    static void YamlReader::inplaceMap(const std::shared_ptr<Topics> &topics, YAML::Node &node) {
         if(!node.IsMap()) {
             throw std::runtime_error("Expecting a map");
         }
@@ -35,7 +35,7 @@ namespace config {
     }
 
     // NOLINTNEXTLINE(*-no-recursion)
-    void YamlReader::inplaceValue(
+    static void YamlReader::inplaceValue(
         const std::shared_ptr<Topics> &topics, const std::string &key, YAML::Node &node
     ) {
         switch(node.Type()) {
@@ -54,7 +54,7 @@ namespace config {
     }
 
     // NOLINTNEXTLINE(*-no-recursion)
-    data::ValueType YamlReader::rawValue(YAML::Node &node) {
+    static data::ValueType YamlReader::rawValue(YAML::Node &node) {
         switch(node.Type()) {
         case YAML::NodeType::Map:
             return rawMapValue(node);
@@ -76,7 +76,7 @@ namespace config {
     }
 
     // NOLINTNEXTLINE(*-no-recursion)
-    void YamlReader::nestedMapValue(
+    static void YamlReader::nestedMapValue(
         const std::shared_ptr<Topics> &topics, const std::string &key, YAML::Node &node
     ) {
         std::shared_ptr<Topics> nested = topics->createInteriorChild(key, _timestamp);
@@ -84,7 +84,7 @@ namespace config {
     }
 
     // NOLINTNEXTLINE(*-no-recursion)
-    data::ValueType YamlReader::rawSequenceValue(YAML::Node &node) {
+    static data::ValueType YamlReader::rawSequenceValue(YAML::Node &node) {
         std::shared_ptr<data::SharedList> newList{std::make_shared<data::SharedList>(_environment)};
         int idx = 0;
         for(auto i : node) {
@@ -94,7 +94,7 @@ namespace config {
     }
 
     // NOLINTNEXTLINE(*-no-recursion)
-    data::ValueType YamlReader::rawMapValue(YAML::Node &node) {
+    static data::ValueType YamlReader::rawMapValue(YAML::Node &node) {
         std::shared_ptr<data::SharedStruct> newMap{
             std::make_shared<data::SharedStruct>(_environment)};
         for(auto i : node) {
@@ -104,7 +104,7 @@ namespace config {
         return newMap;
     }
 
-    void YamlHelper::write(
+    static void YamlHelper::write(
         data::Environment &environment,
         util::CommitableFile &path,
         const std::shared_ptr<Topics> &node
@@ -116,7 +116,7 @@ namespace config {
         path.commit();
     }
 
-    void YamlHelper::write(
+    static void YamlHelper::write(
         data::Environment &environment, std::ofstream &stream, const std::shared_ptr<Topics> &node
     ) {
         YAML::Emitter out;
@@ -128,7 +128,7 @@ namespace config {
     }
 
     // NOLINTNEXTLINE(*-no-recursion)
-    void YamlHelper::serialize(
+    static void YamlHelper::serialize(
         data::Environment &environment, YAML::Emitter &emitter, const std::shared_ptr<Topics> &node
     ) {
         emitter << YAML::BeginMap;
@@ -149,7 +149,7 @@ namespace config {
     }
 
     // NOLINTNEXTLINE(*-no-recursion)
-    void YamlHelper::serialize(
+    static void YamlHelper::serialize(
         data::Environment &environment, YAML::Emitter &emitter, const data::StructElement &value
     ) {
         switch(value.getType()) {
diff --git a/nucleus/src/data/environment.cpp b/nucleus/src/data/environment.cpp
index 25bf608..45c4134 100644
--- a/nucleus/src/data/environment.cpp
+++ b/nucleus/src/data/environment.cpp
@@ -29,7 +29,7 @@ namespace data {
         }
     }
 
-    std::optional<std::string> SysProperties::get(std::string_view name) const {
+    static std::optional<std::string> SysProperties::get(std::string_view name) {
         std::shared_lock guard{_mutex};
         std::string key{name};
         const auto &i = _cache.find(key);
@@ -40,14 +40,14 @@ namespace data {
         }
     }
 
-    bool SysProperties::exists(std::string_view name) const {
+    bool SysProperties::exists(std::string_view name) {
         std::shared_lock guard{_mutex};
         std::string key{name};
         const auto &i = _cache.find(key);
         return i != _cache.end();
     }
 
-    void SysProperties::put(std::string_view name, const std::string &value) {
+    static void SysProperties::put(std::string_view name, const std::string &value) {
         std::unique_lock guard{_mutex};
         _cache.emplace(name, value);
     }
diff --git a/nucleus/src/data/environment.hpp b/nucleus/src/data/environment.hpp
index ad55a0d..bda248f 100644
--- a/nucleus/src/data/environment.hpp
+++ b/nucleus/src/data/environment.hpp
@@ -10,22 +10,22 @@ namespace data {
     class SysProperties {
     private:
         mutable std::shared_mutex _mutex;
-        std::map<std::string, std::string> _cache;
+        std::map<std::string, std::string> _cache{};
 
     public:
         static constexpr auto HOME = {"HOME"};
 
         SysProperties() = default;
 
-        void parseEnv(char *envp[]); // NOLINT(*-avoid-c-arrays)
+        static void parseEnv(char *envp[]); // NOLINT(*-avoid-c-arrays)
 
         std::optional<std::string> get(std::string_view name) const;
 
         void put(std::string_view name, const std::string &value);
 
-        bool exists(std::string_view name) const;
+        static bool exists(std::string_view name) ;
 
-        void remove(std::string_view name);
+        static void remove(std::string_view name);
     };
 
     struct Environment { // NOLINT(*-special-member-functions)
diff --git a/nucleus/src/data/handle_table.cpp b/nucleus/src/data/handle_table.cpp
index a608ed6..6b2f6a5 100644
--- a/nucleus/src/data/handle_table.cpp
+++ b/nucleus/src/data/handle_table.cpp
@@ -2,7 +2,7 @@
 #include "environment.hpp"
 
 namespace data {
-    ObjectAnchor HandleTable::tryGet(ObjHandle handle) const {
+    ObjectAnchor HandleTable::tryGet(ObjHandle handle) {
         std::shared_lock guard{_mutex};
         auto i = _handles.find(handle);
         if(i == _handles.end()) {
diff --git a/nucleus/src/data/handle_table.hpp b/nucleus/src/data/handle_table.hpp
index 1221097..dfaed55 100644
--- a/nucleus/src/data/handle_table.hpp
+++ b/nucleus/src/data/handle_table.hpp
@@ -67,7 +67,7 @@ namespace data {
 
     public:
         // Retrieve object, safe if handle does not exist
-        ObjectAnchor tryGet(ObjHandle handle) const;
+        static ObjectAnchor tryGet(ObjHandle handle) ;
         // Retrieve object, handle is expected to exist
         ObjectAnchor get(ObjHandle handle) const;
 
@@ -80,6 +80,6 @@ namespace data {
         // Creates a new handle, even if one exists
         ObjectAnchor create(const ObjectAnchor &partial);
         // remove a handle
-        void remove(const ObjectAnchor &anchor);
+        static void remove(const ObjectAnchor &anchor);
     };
 } // namespace data
diff --git a/nucleus/src/data/shared_buffer.cpp b/nucleus/src/data/shared_buffer.cpp
index e73290e..45343e7 100644
--- a/nucleus/src/data/shared_buffer.cpp
+++ b/nucleus/src/data/shared_buffer.cpp
@@ -72,7 +72,7 @@ namespace data {
         _buffer.resize(newSize, 0);
     }
 
-    uint32_t SharedBuffer::get(int idx, MemoryView bytes) const {
+    uint32_t SharedBuffer::get(int idx, MemoryView bytes) {
         std::shared_lock guard{_mutex};
         size_t realIdx;
         if(idx < 0) {
diff --git a/nucleus/src/data/shared_buffer.hpp b/nucleus/src/data/shared_buffer.hpp
index 610551e..971c170 100644
--- a/nucleus/src/data/shared_buffer.hpp
+++ b/nucleus/src/data/shared_buffer.hpp
@@ -13,14 +13,14 @@ namespace data {
     protected:
         static constexpr uint32_t MAX_BUFFER_SIZE{0x100000};
 
-        std::vector<char> _buffer;
+        std::vector<char> _buffer{};
         mutable std::shared_mutex _mutex;
 
         void rootsCheck(const ContainerModelBase *target) const override {
             // no-op
         }
 
-        void putOrInsert(int32_t idx, ConstMemoryView bytes, bool insert);
+      static   void putOrInsert(int32_t idx, ConstMemoryView bytes, bool insert);
 
     public:
         explicit SharedBuffer(Environment &environment) : ContainerModelBase{environment} {
@@ -29,7 +29,7 @@ namespace data {
         void put(int32_t idx, ConstMemoryView bytes);
         void insert(int32_t idx, ConstMemoryView bytes);
         uint32_t size() const override;
-        void resize(uint32_t newSize);
-        uint32_t get(int idx, MemoryView bytes) const;
+      static   void resize(uint32_t newSize);
+      static   uint32_t get(int idx, MemoryView bytesst;
     };
 } // namespace data
diff --git a/nucleus/src/data/shared_list.hpp b/nucleus/src/data/shared_list.hpp
index 8201b6e..fbbb3c5 100644
--- a/nucleus/src/data/shared_list.hpp
+++ b/nucleus/src/data/shared_list.hpp
@@ -9,7 +9,7 @@ namespace data {
     protected:
         static constexpr uint32_t MAX_LIST_SIZE{0x10000};
 
-        std::vector<StructElement> _elements;
+        std::vector<StructElement> _elements{};
         mutable std::shared_mutex _mutex;
 
         void rootsCheck(const ContainerModelBase *target) const override;
diff --git a/nucleus/src/data/shared_struct.cpp b/nucleus/src/data/shared_struct.cpp
index a2e18ea..e3859f5 100644
--- a/nucleus/src/data/shared_struct.cpp
+++ b/nucleus/src/data/shared_struct.cpp
@@ -47,7 +47,7 @@ namespace data {
         return i != _elements.end();
     }
 
-    std::vector<data::StringOrd> SharedStruct::getKeys() const {
+    static std::vector<data::StringOrd> SharedStruct::getKeys() {
         std::vector<data::StringOrd> keys;
         std::shared_lock guard{_mutex};
         keys.reserve(_elements.size());
diff --git a/nucleus/src/data/shared_struct.hpp b/nucleus/src/data/shared_struct.hpp
index b37eb21..6a8c931 100644
--- a/nucleus/src/data/shared_struct.hpp
+++ b/nucleus/src/data/shared_struct.hpp
@@ -8,7 +8,7 @@ namespace data {
      */
     class SharedStruct : public StructModelBase {
     protected:
-        std::map<StringOrd, StructElement, StringOrd::CompLess> _elements;
+        std::map<StringOrd, StructElement, StringOrd::CompLess> _elements{};
         mutable std::shared_mutex _mutex;
 
         void rootsCheck(const ContainerModelBase *target) const override;
diff --git a/nucleus/src/data/string_table.hpp b/nucleus/src/data/string_table.hpp
index df99c43..2750258 100644
--- a/nucleus/src/data/string_table.hpp
+++ b/nucleus/src/data/string_table.hpp
@@ -48,10 +48,10 @@ namespace data {
         InternedString &operator=(InternedString &&) = default;
         ~InternedString() = default;
 
-        InternedString(std::string_view sv) : _value{sv} {
+        explicit InternedString(std::string_view sv) : _value{sv} {
         } // NOLINT(*-explicit-constructor)
 
-        InternedString(std::string s) : _value{std::move(s)} {
+        explicit InternedString(std::string s) : _value{std::move(s)} {
         } // NOLINT(*-explicit-constructor)
 
         operator std::string() const { // NOLINT(*-explicit-constructor)
diff --git a/nucleus/src/data/struct_model.cpp b/nucleus/src/data/struct_model.cpp
index ee0065a..99bd1b9 100644
--- a/nucleus/src/data/struct_model.cpp
+++ b/nucleus/src/data/struct_model.cpp
@@ -7,7 +7,7 @@ namespace data {
     ) {
         std::unique_lock cycleGuard{_environment.cycleCheckMutex, std::defer_lock};
 
-        if(element.isContainer()) {
+        if(data::StructElement::isContainer()) {
             std::shared_ptr<data::ContainerModelBase> otherContainer = element.getContainer();
             if(otherContainer) {
                 // prepare for cycle checks
diff --git a/nucleus/src/data/struct_model.hpp b/nucleus/src/data/struct_model.hpp
index c8f802a..271444f 100644
--- a/nucleus/src/data/struct_model.hpp
+++ b/nucleus/src/data/struct_model.hpp
@@ -46,8 +46,7 @@ namespace data {
         ValueType _value;
 
     public:
-        StructElement() : _value{} {
-        }
+        StructElement() : _value{} = default;
 
         StructElement(ValueType v) : _value(std::move(v)) { // NOLINT(*-explicit-constructor)
         }
@@ -101,7 +100,7 @@ namespace data {
             return _value.index() == OBJECT;
         }
 
-        [[nodiscard]] bool isContainer() const {
+        [[nodiscard]] static bool isContainer() {
             return isType<ContainerModelBase>();
         }
 
@@ -113,7 +112,7 @@ namespace data {
             return _value.index() == NONE;
         }
 
-        [[nodiscard]] bool getBool() const {
+        [[nodiscard]] static bool getBool() {
             switch(_value.index()) {
             case BOOL:
                 return std::get<bool>(_value);
@@ -130,7 +129,7 @@ namespace data {
             }
         }
 
-        [[nodiscard]] uint64_t getInt() const {
+        [[nodiscard]] static uint64_t getInt() {
             switch(_value.index()) {
             case BOOL:
                 return std::get<bool>(_value) ? 1 : 0;
@@ -145,7 +144,7 @@ namespace data {
             }
         }
 
-        [[nodiscard]] double getDouble() const {
+        [[nodiscard]] static double getDouble() {
             switch(_value.index()) {
             case BOOL:
                 return std::get<bool>(_value) ? 1.0 : 0.0;
@@ -160,7 +159,7 @@ namespace data {
             }
         }
 
-        [[nodiscard]] std::string getString() const {
+        [[nodiscard]] static std::string getString() {
             switch(_value.index()) {
             case BOOL:
                 return std::get<bool>(_value) ? "true" : "false";
@@ -175,7 +174,7 @@ namespace data {
             }
         }
 
-        [[nodiscard]] std::shared_ptr<TrackedObject> getObject() const {
+        [[nodiscard]] static std::shared_ptr<TrackedObject> getObject() {
             switch(_value.index()) {
             case NONE:
                 return {};
@@ -186,7 +185,7 @@ namespace data {
             }
         }
 
-        [[nodiscard]] std::shared_ptr<ContainerModelBase> getContainer() const {
+        [[nodiscard]] static std::shared_ptr<ContainerModelBase> getContainer() {
             return castObject<ContainerModelBase>();
         }
 
@@ -249,7 +248,7 @@ namespace data {
         // Used for lists and structures
         //
         virtual void rootsCheck(const ContainerModelBase *target) const = 0;
-        virtual uint32_t size() const = 0;
+        [[nodiscard]] virtual uint32_t size() const = 0;
         void checkedPut(
             const StructElement &element,
             const std::function<void(const StructElement &)> &putAction
@@ -263,8 +262,8 @@ namespace data {
     class StructModelBase : public ContainerModelBase {
     protected:
         virtual void putImpl(StringOrd handle, const StructElement &element) = 0;
-        virtual bool hasKeyImpl(StringOrd handle) const = 0;
-        virtual StructElement getImpl(StringOrd handle) const = 0;
+        [[nodiscard]] virtual bool hasKeyImpl(StringOrd handle) const = 0;
+        [[nodiscard]] virtual StructElement getImpl(StringOrd handle) const = 0;
 
     public:
         explicit StructModelBase(Environment &environment) : ContainerModelBase{environment} {
@@ -272,12 +271,12 @@ namespace data {
 
         void put(StringOrd handle, const StructElement &element);
         void put(std::string_view sv, const StructElement &element);
-        virtual std::vector<data::StringOrd> getKeys() const = 0;
-        bool hasKey(StringOrd handle) const;
-        bool hasKey(std::string_view sv) const;
-        StructElement get(StringOrd handle) const;
-        StructElement get(std::string_view sv) const;
-        virtual std::shared_ptr<StructModelBase> copy() const = 0;
+        [[nodiscard]] virtual std::vector<data::StringOrd> getKeys() const = 0;
+        [[nodiscard]] bool hasKey(StringOrd handle) const;
+        [[nodiscard]] bool hasKey(std::string_view sv) const;
+        [[nodiscard]] StructElement get(StringOrd handle) const;
+        [[nodiscard]] StructElement get(std::string_view sv) const;
+        [[nodiscard]] virtual std::shared_ptr<StructModelBase> copy() const = 0;
     };
 
     //
@@ -291,8 +290,8 @@ namespace data {
 
         virtual void put(int32_t idx, const StructElement &element) = 0;
         virtual void insert(int32_t idx, const StructElement &element) = 0;
-        virtual StructElement get(int idx) const = 0;
-        virtual std::shared_ptr<ListModelBase> copy() const = 0;
+        [[nodiscard]] virtual StructElement get(int idx) const = 0;
+        [[nodiscard]] virtual std::shared_ptr<ListModelBase> copy() const = 0;
     };
 
     inline StructElement::StructElement(const std::shared_ptr<TrackedObject> &p) {
diff --git a/nucleus/src/data/tracked_object.cpp b/nucleus/src/data/tracked_object.cpp
index c85c1a4..07ae2de 100644
--- a/nucleus/src/data/tracked_object.cpp
+++ b/nucleus/src/data/tracked_object.cpp
@@ -42,7 +42,7 @@ namespace data {
         _roots.erase(anchor.getHandle());
     }
 
-    std::vector<ObjectAnchor> TrackingScope::getRootsHelper(
+    static std::vector<ObjectAnchor> TrackingScope::getRootsHelper(
         const std::weak_ptr<TrackingScope> &assumedOwner
     ) {
         std::shared_lock guard{_mutex};
diff --git a/nucleus/src/data/tracked_object.hpp b/nucleus/src/data/tracked_object.hpp
index 73708e8..bcd5b79 100644
--- a/nucleus/src/data/tracked_object.hpp
+++ b/nucleus/src/data/tracked_object.hpp
@@ -123,10 +123,10 @@ namespace data {
         friend class HandleTable;
 
     protected:
-        std::map<ObjHandle, std::shared_ptr<TrackedObject>, ObjHandle::CompLess> _roots;
+        std::map<ObjHandle, std::shared_ptr<TrackedObject>, ObjHandle::CompLess> _roots{};
         mutable std::shared_mutex _mutex;
-        void removeRootHelper(const ObjectAnchor &anchor);
-        ObjectAnchor createRootHelper(const ObjectAnchor &anchor);
+        static void removeRootHelper(const ObjectAnchor &anchor);
+        static ObjectAnchor createRootHelper(const ObjectAnchor &anchor);
         std::vector<ObjectAnchor> getRootsHelper(const std::weak_ptr<TrackingScope> &assumedOwner);
 
     public:
@@ -142,11 +142,11 @@ namespace data {
         ObjectAnchor reanchor(const ObjectAnchor &anchor);
         void remove(const ObjectAnchor &anchor);
 
-        std::shared_ptr<const TrackingScope> scopeRef() const {
+        static std::shared_ptr<const TrackingScope> scopeRef() {
             return ref<TrackingScope>();
         }
 
-        std::shared_ptr<TrackingScope> scopeRef() {
+        static std::shared_ptr<TrackingScope> scopeRef() {
             return ref<TrackingScope>();
         }
 
diff --git a/nucleus/src/deployment/device_configuration.cpp b/nucleus/src/deployment/device_configuration.cpp
index ac08d1d..e308e76 100644
--- a/nucleus/src/deployment/device_configuration.cpp
+++ b/nucleus/src/deployment/device_configuration.cpp
@@ -17,7 +17,7 @@ namespace deployment {
         // TODO: OnAnyChange
     }
 
-    std::string DeviceConfiguration::getNucleusComponentName() {
+    static std::string DeviceConfiguration::getNucleusComponentName() {
         std::unique_lock guard{_mutex};
         if(!_nucleusComponentNameCache.empty()) {
             if(_kernel.findServiceTopic(_nucleusComponentNameCache)) {
@@ -39,7 +39,7 @@ namespace deployment {
         return getTopics(configs.FLEET_STATUS_CONFIG_TOPICS);
     }
 
-    std::string DeviceConfiguration::initNucleusComponentName() {
+    static std::string DeviceConfiguration::initNucleusComponentName() {
         // TODO: missing code
         return {};
     }
@@ -108,7 +108,7 @@ namespace deployment {
     //    void DeviceConfiguration::reconfigureLogging(LogConfigUpdate) {
     //    }
 
-    std::optional<std::string> DeviceConfiguration::getComponentType(std::string serviceName) {
+    static std::optional<std::string> DeviceConfiguration::getComponentType(std::string serviceName) {
         std::optional<config::Topic> componentType =
             _kernel.getConfig().find({"services", serviceName, "componentType"});
         if(componentType.has_value()) {
@@ -149,7 +149,7 @@ namespace deployment {
     }
 
     // Get thing name configuration. Also adds the thing name to the env vars if it has changed.
-    config::Topic DeviceConfiguration::getThingName() {
+    static config::Topic DeviceConfiguration::getThingName() {
         config::Topic thingNameTopic =
             _kernel.getConfig()
                 .lookup({configs.SYSTEM_NAMESPACE_KEY, configs.DEVICE_PARAM_THING_NAME})
@@ -246,7 +246,7 @@ namespace deployment {
         return getNetworkProxyNamespace()->lookupTopics({configs.DEVICE_PROXY_NAMESPACE});
     }
 
-    std::string DeviceConfiguration::getNoProxyAddresses() {
+    static std::string DeviceConfiguration::getNoProxyAddresses() {
         config::Topic potentialTopic =
             getNetworkProxyNamespace()->lookup({configs.DEVICE_PARAM_NO_PROXY_ADDRESSES});
         return potentialTopic.empty() ? "" : potentialTopic.getString();
@@ -321,7 +321,7 @@ namespace deployment {
         }
     }
 
-    bool DeviceConfiguration::provisionInfoNodeChanged(
+    static bool DeviceConfiguration::provisionInfoNodeChanged(
         const std::shared_ptr<config::ConfigNode> &node, bool checkThingNameOnly
     ) {
         // TODO: missing code
@@ -341,7 +341,7 @@ namespace deployment {
         );
     }
 
-    std::string DeviceConfiguration::getNucleusVersion() {
+    static std::string DeviceConfiguration::getNucleusVersion() {
         std::string version;
         std::shared_ptr<config::Topics> componentTopic =
             _kernel.findServiceTopic(getNucleusComponentName());
@@ -354,12 +354,12 @@ namespace deployment {
         return configs.FALLBACK_VERSION;
     }
 
-    std::string DeviceConfiguration::getVersionFromBuildRecipeFile() {
+    static std::string DeviceConfiguration::getVersionFromBuildRecipeFile() {
         // TODO: missing code
         return {};
     }
 
-    void DeviceConfiguration::validateDeviceConfiguration(
+    static void DeviceConfiguration::validateDeviceConfiguration(
         std::string_view thingName,
         std::string_view certificateFilePath,
         std::string_view privateKeyPath,
@@ -408,7 +408,7 @@ namespace deployment {
     // Validate the IoT credential and data endpoint with the provided AWS region. Currently, it
     // checks that if the endpoints are provided, then the AWS region should be a part of the
     // URL.
-    void DeviceConfiguration::validateEndpoints(
+    static void DeviceConfiguration::validateEndpoints(
         std::string_view awsRegion,
         std::string_view iotCredEndpoint,
         std::string_view iotDataEndpoint
diff --git a/nucleus/src/deployment/device_configuration.hpp b/nucleus/src/deployment/device_configuration.hpp
index fd6e1f1..300a013 100644
--- a/nucleus/src/deployment/device_configuration.hpp
+++ b/nucleus/src/deployment/device_configuration.hpp
@@ -132,13 +132,13 @@ namespace deployment {
     };
 
     class DeviceConfiguration {
-        mutable std::shared_mutex _mutex;
+        mutable std::shared_mutex _mutex{};
         data::Environment &_environment;
         lifecycle::Kernel &_kernel;
-        std::string _nucleusComponentNameCache;
-        std::shared_ptr<util::NucleusPaths> _nucleusPaths;
+        std::string _nucleusComponentNameCache{};
+        std::shared_ptr<util::NucleusPaths> _nucleusPaths{};
         std::atomic_bool _deviceConfigValidationCachedResult{false};
-        std::shared_ptr<config::Topics> _loggingTopics;
+        std::shared_ptr<config::Topics> _loggingTopics{};
 
     public:
         const DeviceConfigConsts configs;
@@ -215,7 +215,7 @@ namespace deployment {
         config::Topic gets3EndpointType();
         // void onAnyChange(ChildChanged);
         void validate();
-        void validate(bool);
+        static void validate(bool);
         bool isDeviceConfiguredToTalkToCloud();
         bool provisionInfoNodeChanged(const std::shared_ptr<config::ConfigNode> &node, bool);
         config::Topic getTopic(data::StringOrdInit);
diff --git a/nucleus/src/lifecycle/command_line.cpp b/nucleus/src/lifecycle/command_line.cpp
index ac1e902..4b21606 100644
--- a/nucleus/src/lifecycle/command_line.cpp
+++ b/nucleus/src/lifecycle/command_line.cpp
@@ -47,7 +47,7 @@ namespace lifecycle {
         _kernel.getPaths()->setRootPath(root, true /* passive */);
     }
 
-    std::string CommandLine::nextArg(
+    static std::string CommandLine::nextArg(
         const std::vector<std::string> &args, std::vector<std::string>::const_iterator &iter
     ) {
         if(iter == args.end()) {
@@ -58,7 +58,7 @@ namespace lifecycle {
         return v;
     }
 
-    void CommandLine::parseHome(data::SysProperties &env) {
+    static void CommandLine::parseHome(data::SysProperties &env) {
         std::optional<std::string> homePath = env.get("HOME");
         std::shared_ptr<util::NucleusPaths> paths = _kernel.getPaths();
         if(homePath.has_value() && !homePath.value().empty()) {
diff --git a/nucleus/src/lifecycle/command_line.hpp b/nucleus/src/lifecycle/command_line.hpp
index 0f388b4..3f00137 100644
--- a/nucleus/src/lifecycle/command_line.hpp
+++ b/nucleus/src/lifecycle/command_line.hpp
@@ -11,13 +11,13 @@ namespace lifecycle {
     private:
         data::Global &_global;
         lifecycle::Kernel &_kernel;
-        std::shared_ptr<util::NucleusPaths> _nucleusPaths;
+        std::shared_ptr<util::NucleusPaths> _nucleusPaths{};
 
         std::filesystem::path _providedConfigPath;
         std::filesystem::path _providedInitialConfigPath;
-        std::string _awsRegionFromCmdLine;
-        std::string _envStageFromCmdLine;
-        std::string _defaultUserFromCmdLine;
+        std::string _awsRegionFromCmdLine{};
+        std::string _envStageFromCmdLine{};
+        std::string _defaultUserFromCmdLine{};
 
         static std::string nextArg(
             const std::vector<std::string> &args, std::vector<std::string>::const_iterator &iter
diff --git a/nucleus/src/lifecycle/kernel.cpp b/nucleus/src/lifecycle/kernel.cpp
index 0e8bd1b..9eb7c27 100644
--- a/nucleus/src/lifecycle/kernel.cpp
+++ b/nucleus/src/lifecycle/kernel.cpp
@@ -289,7 +289,7 @@ namespace lifecycle {
         getConfig().publishQueue().stop();
     }
 
-    std::shared_ptr<config::Topics> Kernel::findServiceTopic(const std::string_view &serviceName) {
+    static std::shared_ptr<config::Topics> Kernel::findServiceTopic(const std::string_view &serviceName) {
         std::shared_ptr<config::ConfigNode> node =
             getConfig().root()->createInteriorChild(SERVICES_TOPIC_KEY)->getNode(serviceName);
         return std::dynamic_pointer_cast<config::Topics>(node);
diff --git a/nucleus/src/lifecycle/kernel.hpp b/nucleus/src/lifecycle/kernel.hpp
index f3a095f..78b9da9 100644
--- a/nucleus/src/lifecycle/kernel.hpp
+++ b/nucleus/src/lifecycle/kernel.hpp
@@ -40,10 +40,10 @@ namespace lifecycle {
 
     class Kernel : public util::RefObject<Kernel> {
         data::Global &_global;
-        std::shared_ptr<util::NucleusPaths> _nucleusPaths;
+        std::shared_ptr<util::NucleusPaths> _nucleusPaths{};
         std::shared_ptr<RootPathWatcher> _rootPathWatcher;
-        tasks::FixedTaskThreadScope _mainThread;
-        std::unique_ptr<config::TlogWriter> _tlog;
+        tasks::FixedTaskThreadScope _mainThread{};
+        std::unique_ptr<config::TlogWriter> _tlog{};
         deployment::DeploymentStage _deploymentStageAtLaunch{deployment::DeploymentStage::DEFAULT};
         std::unique_ptr<deployment::DeviceConfiguration> _deviceConfiguration{nullptr};
         std::unique_ptr<KernelAlternatives> _kernelAlts{nullptr};
@@ -71,29 +71,28 @@ namespace lifecycle {
             CommandLine &commandLine, const std::filesystem::path &configFile
         );
         void initConfigAndTlog(CommandLine &commandLine);
-        void updateDeviceConfiguration(CommandLine &commandLine);
+        static void updateDeviceConfiguration(CommandLine &commandLine);
         void initializeNucleusFromRecipe();
         void setupProxy();
-        void launchBootstrap();
-        void launchLifecycle();
-        void launchKernelDeployment();
+        static void launchBootstrap();
+        static void launchLifecycle();
+        static void launchKernelDeployment();
         static bool handleIncompleteTlogTruncation(const std::filesystem::path &tlogFile);
-        void readConfigFromBackUpTLog(
+        static void readConfigFromBackUpTLog(
             const std::filesystem::path &tlogFile, const std::filesystem::path &bootstrapTlogFile
         );
         void writeEffectiveConfigAsTransactionLog(const std::filesystem::path &tlogFile);
-        void writeEffectiveConfig();
+        static void writeEffectiveConfig();
         void writeEffectiveConfig(const std::filesystem::path &configFile);
         std::shared_ptr<config::Topics> findServiceTopic(const std::string_view &serviceName);
 
         void stopAllServices(std::chrono::seconds timeoutSeconds);
         void shutdown(std::chrono::seconds timeoutSeconds, int exitCode);
         void shutdown(
-            std::chrono::seconds timeoutSeconds = std::chrono::seconds(SHUTDOWN_TIMEOUT_SECONDS)
+  static_cast<std::chrono::seconds>o::seconds timeoutSeconds = std::chrono::seconds(SHUTDOWN_TIMEOUT_SECONDS)
         );
 
-        void softShutdown(
-            std::chrono::seconds expireTime = std::chrono::seconds(SHUTDOWN_TIMEOUT_SECONDS)
+        void softShutdownstatic_cast<std::chrono::seconds>hrono::seconds expireTime = std::chrono::seconds(SHUTDOWN_TIMEOUT_SECONDS)
         );
 
         std::shared_ptr<util::NucleusPaths> getPaths() {
diff --git a/nucleus/src/lifecycle/kernel_alternatives.hpp b/nucleus/src/lifecycle/kernel_alternatives.hpp
index b7456eb..16ea156 100644
--- a/nucleus/src/lifecycle/kernel_alternatives.hpp
+++ b/nucleus/src/lifecycle/kernel_alternatives.hpp
@@ -7,15 +7,15 @@ namespace deployment {}
 namespace lifecycle {
 
     class KernelAlternatives {
-        std::shared_ptr<util::NucleusPaths> _nucleusPaths;
+        std::shared_ptr<util::NucleusPaths> _nucleusPaths{};
 
         std::filesystem::path getAltsDir();
-        std::filesystem::path getLoaderPathFromLaunchDir(const std::filesystem::path);
+        std::filesystem::path getLoaderPathFromLaunchDir(std::filesystem::path);
 
-        bool validateLaunchDirSetup(const std::filesystem::path);
+        bool validateLaunchDirSetup(std::filesystem::path);
 
-        void cleanupLaunchDirectoryLink(const std::filesystem::path);
-        void cleanupLaunchDirectorySingleLevel(const std::filesystem::path);
+        void cleanupLaunchDirectoryLink(std::filesystem::path);
+        void cleanupLaunchDirectorySingleLevel(std::filesystem::path);
 
     public:
         explicit KernelAlternatives(std::shared_ptr<util::NucleusPaths> nucleusPaths);
@@ -26,20 +26,20 @@ namespace lifecycle {
 
         std::filesystem::path getLaunchParamsPath();
 
-        void writeLaunchParamsToFile(const std::string content);
+        void writeLaunchParamsToFile(std::string content);
         bool isLaunchDirSetup();
         void validateLaunchDirSetupVerbose();
         void setupInitLaunchDirIfAbsent();
 
-        void relinkInitLaunchDir(const std::filesystem::path, bool);
+        void relinkInitLaunchDir(std::filesystem::path, bool);
         std::filesystem::path locateCurrentKernelUnpackDir();
 
         deployment::DeploymentStage determineDeploymentStage();
         void activationSucceeds();
         void prepareRollback();
         void rollbackCompletes();
-        void prepareBootstrap(const std::string);
-        void setupLinkToDirectory(const std::filesystem::path, const std::filesystem::path);
+        void prepareBootstrap(std::string);
+        void setupLinkToDirectory(std::filesystem::path, std::filesystem::path);
 
         void cleanupLaunchDirectoryLinks();
     };
diff --git a/nucleus/src/plugins/plugin_loader.cpp b/nucleus/src/plugins/plugin_loader.cpp
index 3e34ba4..f0b2034 100644
--- a/nucleus/src/plugins/plugin_loader.cpp
+++ b/nucleus/src/plugins/plugin_loader.cpp
@@ -79,7 +79,7 @@ void plugins::PluginLoader::lifecycle(
     }
 }
 
-bool plugins::NativePlugin::lifecycle(
+static bool plugins::NativePlugin::lifecycle(
     data::ObjHandle pluginAnchor,
     data::StringOrd phase,
     const std::shared_ptr<data::StructModelBase> &data
@@ -99,7 +99,7 @@ bool plugins::DelegatePlugin::lifecycle(
     data::ObjHandle pluginAnchor,
     data::StringOrd phase,
     const std::shared_ptr<data::StructModelBase> &data
-) {
+) const {
     uintptr_t delegateContext;
     ggapiLifecycleCallback delegateLifecycle;
     {
@@ -143,7 +143,7 @@ void plugins::PluginLoader::discoverPlugin(const fs::directory_entry &entry) {
     }
 }
 
-void plugins::PluginLoader::loadNativePlugin(const std::string &name) {
+static void plugins::PluginLoader::loadNativePlugin(const std::string &name) {
     std::shared_ptr<NativePlugin> plugin{std::make_shared<NativePlugin>(_environment, name)};
     std::cout << "Loading native plugin from " << name << std::endl;
     plugin->load(name);
@@ -152,27 +152,27 @@ void plugins::PluginLoader::loadNativePlugin(const std::string &name) {
     anchor(plugin);
 }
 
-void plugins::PluginLoader::lifecycleBootstrap(const std::shared_ptr<data::StructModelBase> &data) {
+static void plugins::PluginLoader::lifecycleBootstrap(const std::shared_ptr<data::StructModelBase> &data) {
     data::Handle key = _environment.stringTable.getOrCreateOrd("bootstrap");
     lifecycle(key, data);
 }
 
-void plugins::PluginLoader::lifecycleDiscover(const std::shared_ptr<data::StructModelBase> &data) {
+static void plugins::PluginLoader::lifecycleDiscover(const std::shared_ptr<data::StructModelBase> &data) {
     data::Handle key = _environment.stringTable.getOrCreateOrd("discover");
     lifecycle(key, data);
 }
 
-void plugins::PluginLoader::lifecycleStart(const std::shared_ptr<data::StructModelBase> &data) {
+static void plugins::PluginLoader::lifecycleStart(const std::shared_ptr<data::StructModelBase> &data) {
     data::Handle key = _environment.stringTable.getOrCreateOrd("start");
     lifecycle(key, data);
 }
 
-void plugins::PluginLoader::lifecycleRun(const std::shared_ptr<data::StructModelBase> &data) {
+static void plugins::PluginLoader::lifecycleRun(const std::shared_ptr<data::StructModelBase> &data) {
     data::Handle key = _environment.stringTable.getOrCreateOrd("run");
     lifecycle(key, data);
 }
 
-void plugins::PluginLoader::lifecycleTerminate(const std::shared_ptr<data::StructModelBase> &data) {
+static void plugins::PluginLoader::lifecycleTerminate(const std::shared_ptr<data::StructModelBase> &data) {
     data::Handle key = _environment.stringTable.getOrCreateOrd("terminate");
     lifecycle(key, data);
 }
diff --git a/nucleus/src/plugins/plugin_loader.hpp b/nucleus/src/plugins/plugin_loader.hpp
index d3ba4f8..b213d04 100644
--- a/nucleus/src/plugins/plugin_loader.hpp
+++ b/nucleus/src/plugins/plugin_loader.hpp
@@ -24,7 +24,7 @@ namespace plugins {
     //
     class AbstractPlugin : public data::TrackingScope {
     protected:
-        std::string _moduleName;
+        std::string _moduleName{};
 
     public:
         explicit AbstractPlugin(data::Environment &environment, const std::string_view &name)
@@ -114,7 +114,7 @@ namespace plugins {
         }
 
         void discoverPlugins(const std::filesystem::path &pluginDir);
-        void discoverPlugin(const std::filesystem::directory_entry &entry);
+      static   void discoverPlugin(const std::filesystem::directory_entry &entry);
 
         void loadNativePlugin(const std::string &name);
 
diff --git a/nucleus/src/pubsub/local_topics.cpp b/nucleus/src/pubsub/local_topics.cpp
index 9729a2f..979520e 100644
--- a/nucleus/src/pubsub/local_topics.cpp
+++ b/nucleus/src/pubsub/local_topics.cpp
@@ -50,7 +50,7 @@ namespace pubsub {
         }
     }
 
-    std::shared_ptr<Listener> Listeners::newReceiver(std::unique_ptr<AbstractCallback> &callback) {
+    static std::shared_ptr<Listener> Listeners::newReceiver(std::unique_ptr<AbstractCallback> &callback) {
         std::shared_ptr<Listener> receiver{
             std::make_shared<Listener>(_environment, _topicOrd, this, callback)};
         std::unique_lock guard{_environment.sharedLocalTopicsMutex};
@@ -58,7 +58,7 @@ namespace pubsub {
         return receiver;
     }
 
-    std::shared_ptr<Listeners> PubSubManager::tryGetListeners(data::StringOrd topicOrd) {
+    static std::shared_ptr<Listeners> PubSubManager::tryGetListeners(data::StringOrd topicOrd) {
         std::shared_lock guard{_environment.sharedLocalTopicsMutex};
         auto i = _topics.find(topicOrd);
         if(i == _topics.end()) {
@@ -68,7 +68,7 @@ namespace pubsub {
         }
     }
 
-    std::shared_ptr<Listeners> PubSubManager::getListeners(data::StringOrd topicOrd) {
+    static std::shared_ptr<Listeners> PubSubManager::getListeners(data::StringOrd topicOrd) {
         std::shared_ptr<Listeners> receivers = tryGetListeners(topicOrd);
         if(receivers) {
             return receivers;
@@ -84,7 +84,7 @@ namespace pubsub {
         return receivers;
     }
 
-    data::ObjectAnchor PubSubManager::subscribe(
+    static data::ObjectAnchor PubSubManager::subscribe(
         data::ObjHandle anchor,
         data::StringOrd topicOrd,
         std::unique_ptr<AbstractCallback> &callback
@@ -96,7 +96,7 @@ namespace pubsub {
         return root->anchor(receiver); // if handle or root goes away, unsubscribe
     }
 
-    void PubSubManager::insertCallQueue(
+    static void PubSubManager::insertCallQueue(
         std::shared_ptr<tasks::Task> &task, data::StringOrd topicOrd
     ) {
         if(!topicOrd) {
@@ -140,7 +140,7 @@ namespace pubsub {
         ) override;
     };
 
-    std::unique_ptr<tasks::SubTask> Listener::toSubTask() {
+    static std::unique_ptr<tasks::SubTask> Listener::toSubTask() {
         std::shared_lock guard{_environment.sharedLocalTopicsMutex};
         std::shared_ptr<Listener> receiver{std::static_pointer_cast<Listener>(shared_from_this())};
         std::unique_ptr<tasks::SubTask> subTask{new ReceiverSubTask(receiver)};
@@ -176,7 +176,7 @@ namespace pubsub {
         return nullptr;
     }
 
-    std::unique_ptr<tasks::SubTask> CompletionSubTask::of(
+    static std::unique_ptr<tasks::SubTask> CompletionSubTask::of(
         data::StringOrd topicOrd, std::unique_ptr<AbstractCallback> callback
     ) {
         if(topicOrd && callback) {
diff --git a/nucleus/src/pubsub/local_topics.hpp b/nucleus/src/pubsub/local_topics.hpp
index 6571d1b..14fe905 100644
--- a/nucleus/src/pubsub/local_topics.hpp
+++ b/nucleus/src/pubsub/local_topics.hpp
@@ -27,7 +27,7 @@ namespace pubsub {
     // Translated callback exception
     //
     class CallbackError : public std::exception {
-        data::StringOrd _ord;
+        data::StringOrd _ord{};
 
     public:
         constexpr CallbackError(const CallbackError &) noexcept = default;
@@ -63,8 +63,8 @@ namespace pubsub {
 
     class CompletionSubTask : public tasks::SubTask {
     private:
-        data::StringOrd _topicOrd;
-        std::unique_ptr<pubsub::AbstractCallback> _callback;
+        data::StringOrd _topicOrd{};
+        std::unique_ptr<pubsub::AbstractCallback> _callback{};
 
     public:
         explicit CompletionSubTask(
@@ -73,7 +73,7 @@ namespace pubsub {
             : _topicOrd{topicOrd}, _callback{std::move(callback)} {
         }
 
-        std::shared_ptr<data::StructModelBase> runInThread(
+  static       std::shared_ptr<data::StructModelBase> runInThread(
             const std::shared_ptr<tasks::Task> &task,
             const std::shared_ptr<data::StructModelBase> &result
         ) override;
@@ -88,9 +88,9 @@ namespace pubsub {
     //
     class Listener : public data::TrackedObject {
     private:
-        data::StringOrd _topicOrd;
+        data::StringOrd _to{}picOrd;
         std::weak_ptr<Listeners> _parent;
-        std::unique_ptr<AbstractCallback> _callback;
+        std::unique_ptr<AbstractCallback> _ca{}llback;
 
     public:
         Listener(const Listener &) = delete;
@@ -105,7 +105,7 @@ namespace pubsub {
             std::unique_ptr<AbstractCallback> &callback
         );
         std::unique_ptr<tasks::SubTask> toSubTask();
-        std::shared_ptr<data::StructModelBase> runInTaskThread(
+  static       std::shared_ptr<data::StructModelBase> runInTaskThread(
             const std::shared_ptr<tasks::Task> &task,
             const std::shared_ptr<data::StructModelBase> &dataIn
         );
@@ -118,13 +118,13 @@ namespace pubsub {
     class Listeners : public util::RefObject<Listeners> {
     private:
         data::Environment &_environment;
-        data::StringOrd _topicOrd;
+        data::StringOrd _to{}picOrd;
         std::weak_ptr<PubSubManager> _parent;
-        std::vector<std::weak_ptr<Listener>> _listeners;
+        std::vector<std::weak_ptr<Listener>> _lis{}teners;
 
     public:
         Listeners(data::Environment &environment, data::StringOrd topicOrd, PubSubManager *topics);
-        void cleanup();
+  static       void cleanup();
 
         bool isEmpty() {
             return _listeners.empty();
@@ -146,7 +146,7 @@ namespace pubsub {
         explicit PubSubManager(data::Environment &environment) : _environment{environment} {
         }
 
-        void cleanup();
+  static       void cleanup();
         // if listeners exist for a given topic, return those listeners
         std::shared_ptr<Listeners> tryGetListeners(data::StringOrd topicOrd);
         // get listeners, create if there is none for given topic
diff --git a/nucleus/src/tasks/task.cpp b/nucleus/src/tasks/task.cpp
index 5e267d9..38be483 100644
--- a/nucleus/src/tasks/task.cpp
+++ b/nucleus/src/tasks/task.cpp
@@ -3,7 +3,7 @@
 
 namespace tasks {
 
-    data::ObjectAnchor TaskManager::createTask() {
+    static data::ObjectAnchor TaskManager::createTask() {
         auto task{std::make_shared<Task>(_environment)};
         auto taskAnchor{anchor(task)};
         task->setSelf(taskAnchor.getHandle());
@@ -95,7 +95,7 @@ namespace tasks {
         return work;
     }
 
-    void Task::addSubtask(std::unique_ptr<SubTask> subTask) {
+    static void Task::addSubtask(std::unique_ptr<SubTask> subTask) {
         std::unique_lock guard{_mutex};
         _subtasks.emplace_back(std::move(subTask));
     }
@@ -114,12 +114,12 @@ namespace tasks {
         }
     }
 
-    void FixedTaskThread::setDefaultTask(const data::ObjectAnchor &task) {
+    static void FixedTaskThread::setDefaultTask(const data::ObjectAnchor &task) {
         std::unique_lock guard{_mutex};
         _defaultTask = task;
     }
 
-    data::ObjectAnchor FixedTaskThread::getDefaultTask() {
+    static data::ObjectAnchor FixedTaskThread::getDefaultTask() {
         std::unique_lock guard{_mutex};
         return _defaultTask;
     }
@@ -270,7 +270,7 @@ namespace tasks {
         return _lastStatus == Completed;
     }
 
-    Task::Status Task::removeSubtask(std::unique_ptr<SubTask> &subTask) {
+    static Task::Status Task::removeSubtask(std::unique_ptr<SubTask> &subTask) {
         std::unique_lock guard{_mutex};
         if(_subtasks.empty()) {
             return NoSubTasks;
@@ -286,7 +286,7 @@ namespace tasks {
 
     class ThreadSelf {
     private:
-        data::ObjHandle _oldHandle;
+        data::ObjHandle _oldHandle{};
 
     public:
         ThreadSelf(const ThreadSelf &) = delete;
@@ -395,7 +395,7 @@ namespace tasks {
         return isCompleted();
     }
 
-    Task::Status Task::runInThreadCallNext(
+    static Task::Status Task::runInThreadCallNext(
         const std::shared_ptr<Task> &task,
         const std::shared_ptr<data::StructModelBase> &dataIn,
         std::shared_ptr<data::StructModelBase> &dataOut
diff --git a/nucleus/src/tasks/task.hpp b/nucleus/src/tasks/task.hpp
index 9b6e231..de50360 100644
--- a/nucleus/src/tasks/task.hpp
+++ b/nucleus/src/tasks/task.hpp
@@ -33,11 +33,11 @@ namespace tasks {
         friend class TaskManager;
 
     private:
-        std::shared_ptr<data::StructModelBase> _data;
-        std::unique_ptr<SubTask> _finalize;
-        std::list<std::unique_ptr<SubTask>> _subtasks;
-        std::list<std::shared_ptr<TaskThread>> _blockedThreads;
-        data::ObjHandle _self;
+        std::shared_ptr<data::StructModelBase> _data{};
+        std::unique_ptr<SubTask> _finalize{};
+        std::list<std::unique_ptr<SubTask>> _subtasks{};
+        std::list<std::shared_ptr<TaskThread>> _blockedThreads{};
+        data::ObjHandle _self{};
         ExpireTime _timeout; // time before task is automatically cancelled
         Status _lastStatus{Running};
 
@@ -56,27 +56,27 @@ namespace tasks {
             : TrackingScope{environment}, _timeout{ExpireTime::fromNowMillis(-1)} {
         }
 
-        void setSelf(data::ObjHandle self) {
+        static void setSelf(data::ObjHandle self) {
             std::unique_lock guard{_mutex};
             _self = self;
         }
 
-        data::ObjHandle getSelf() {
+        static data::ObjHandle getSelf() {
             std::unique_lock guard{_mutex};
             return _self;
         }
 
-        std::shared_ptr<data::StructModelBase> getData() {
+        static std::shared_ptr<data::StructModelBase> getData() {
             std::unique_lock guard{_mutex};
             return _data;
         }
 
-        void setData(const std::shared_ptr<data::StructModelBase> &newData) {
+        static void setData(const std::shared_ptr<data::StructModelBase> &newData) {
             std::unique_lock guard{_mutex};
             _data = newData;
         }
 
-        std::shared_ptr<TaskThread> getThreadAffinity();
+        static std::shared_ptr<TaskThread> getThreadAffinity();
         void markTaskComplete();
         void cancelTask();
 
@@ -91,22 +91,22 @@ namespace tasks {
         Status removeSubtask(std::unique_ptr<SubTask> &subTask);
         void addSubtask(std::unique_ptr<SubTask> subTask);
 
-        void setCompletion(std::unique_ptr<SubTask> finalize) {
+ static        void setCompletion(std::unique_ptr<SubTask> finalize) {
             std::unique_lock guard{_mutex};
             _finalize = std::move(finalize);
         }
 
-        void setTimeout(const ExpireTime &terminateTime) {
+ static        void setTimeout(const ExpireTime &terminateTime) {
             std::unique_lock guard{_mutex};
             _timeout = terminateTime;
         }
 
-        ExpireTime getTimeout() const {
+ [[nodiscard]] static        ExpireTime getTim const {
             std::unique_lock guard{_mutex};
             return _timeout;
         }
 
-        ExpireTime getTimeout(const ExpireTime &terminalTime) const {
+ [[nodiscard]] static        ExpireTime getTimeout(const ExpireTime &termina const {
             std::unique_lock guard{_mutex};
             if(terminalTime < _timeout) {
                 return terminalTime;
@@ -123,8 +123,8 @@ namespace tasks {
             std::shared_ptr<data::StructModelBase> &dataOut
         );
 
-        void addBlockedThread(const std::shared_ptr<TaskThread> &blockedThread);
-        void removeBlockedThread(const std::shared_ptr<TaskThread> &blockedThread);
+        static void addBlockedThread(const std::shared_ptr<TaskThread> &blockedThread);
+        static void removeBlockedThread(const std::shared_ptr<TaskThread> &blockedThread);
 
         bool isCompleted();
         bool terminatesWait();
@@ -138,7 +138,7 @@ namespace tasks {
     protected:
         data::Environment &_environment;
         std::weak_ptr<TaskManager> _pool;
-        std::list<std::shared_ptr<Task>> _tasks;
+        std::list<std::shared_ptr<Task>> _tasks{};
         std::mutex _mutex;
         std::condition_variable _wake;
         bool _shutdown{false};
@@ -163,8 +163,8 @@ namespace tasks {
         TaskThread &operator=(const TaskThread &) = delete;
         TaskThread &operator=(TaskThread &&) = delete;
         virtual ~TaskThread() = default;
-        void queueTask(const std::shared_ptr<Task> &task);
-        std::shared_ptr<Task> pickupAffinitizedTask();
+        static void queueTask(const std::shared_ptr<Task> &task);
+        static std::shared_ptr<Task> pickupAffinitizedTask();
         std::shared_ptr<Task> pickupPoolTask();
         std::shared_ptr<Task> pickupTask();
         virtual void releaseFixedThread();
@@ -187,7 +187,7 @@ namespace tasks {
 
         void waken() {
             std::unique_lock guard(_mutex);
-            _wake.notify_one();
+            _wake.notify_one(); const
         }
 
         bool isShutdown() {
@@ -215,7 +215,7 @@ namespace tasks {
 
     class FixedTaskThread : public TaskThread {
     protected:
-        data::ObjectAnchor _defaultTask;
+  {}      data::ObjectAnchor _defaultTask;
         std::shared_ptr<FixedTaskThread> _protectThread;
 
     public:
@@ -229,8 +229,8 @@ namespace tasks {
         void bindThreadContext(const data::ObjectAnchor &task);
         void setDefaultTask(const data::ObjectAnchor &task);
         data::ObjectAnchor getDefaultTask();
-        void protect();
-        void unprotect();
+        static void protect();
+        static void unprotect();
         data::ObjectAnchor claimFixedThread();
         void releaseFixedThread() override;
     };
@@ -245,7 +245,7 @@ namespace tasks {
         FixedTaskThreadScope(FixedTaskThreadScope &&) noexcept = default;
         FixedTaskThreadScope &operator=(FixedTaskThreadScope &&) = default;
 
-        ~FixedTaskThreadScope() {
+        ~FixedTaskThreadSexplicit cope() {
             release();
         }
 
@@ -264,7 +264,7 @@ namespace tasks {
         }
 
         void claim(data::Environment &environment, const std::shared_ptr<TaskManager> &manager) {
-            claim(std::make_shared<FixedTaskThread>(environment, manager));
+            claim(std::make_shared<FixedTaskstatic Thread>(environment, manager));
         }
 
         void release() {
@@ -301,10 +301,10 @@ namespace tasks {
 
     class TaskManager : public data::TrackingScope {
     private:
-        std::list<std::shared_ptr<TaskPoolWorker>> _busyWorkers; // assumes small
+        std:{}:list<std::shared_ptr<TaskPoolWorker>> _busyWorkers; // assumes small
                                                                  // pool, else
                                                                  // std::set
-        std::list<std::shared_ptr<TaskPoolWorker>> _idleWorkers; // LIFO
+        std:{}:list<std::shared_ptr<TaskPoolWorker>> _idleWorkers; // LIF{}O
         std::list<std::shared_ptr<Task>> _backlog; // tasks with no thread affinity
                                                    // (assumed async)
         int _maxWorkers{5}; // TODO, from configuration
@@ -314,11 +314,11 @@ namespace tasks {
         }
 
         data::ObjectAnchor createTask();
-        std::shared_ptr<Task> acquireTaskForWorker(TaskThread *worker);
-        std::shared_ptr<Task> acquireTaskWhenStealing(
+        static std::shared_ptr<Task> acquireTaskForWorker(TaskThread *worker);
+        static std::shared_ptr<Task> acquireTaskWhenStealing(
             TaskThread *worker, const std::shared_ptr<Task> &priorityTask
         );
-        bool allocateNextWorker();
-        void queueTask(const std::shared_ptr<Task> &task);
+        static bool allocateNextWorker();
+        static void queueTask(const std::shared_ptr<Task> &task);
     };
 } // namespace tasks
diff --git a/nucleus/src/util/commitable_file.hpp b/nucleus/src/util/commitable_file.hpp
index 0c9b578..a34f3a0 100644
--- a/nucleus/src/util/commitable_file.hpp
+++ b/nucleus/src/util/commitable_file.hpp
@@ -18,9 +18,9 @@ namespace util {
 
     public:
         CommitableFile(const CommitableFile &) = delete;
-        CommitableFile(CommitableFile &&) = default;
+        CommitableFile(CommitableFile &&)  noexcept = default;
         CommitableFile &operator=(const CommitableFile &) = delete;
-        CommitableFile &operator=(CommitableFile &&) = default;
+        CommitableFile &operator=(CommitableFile &&)  noexcept = default;
         explicit CommitableFile(
             std::filesystem::path newPath,
             std::filesystem::path backupPath,
diff --git a/nucleus/src/util/nucleus_paths.cpp b/nucleus/src/util/nucleus_paths.cpp
index 6ac2161..d55f394 100644
--- a/nucleus/src/util/nucleus_paths.cpp
+++ b/nucleus/src/util/nucleus_paths.cpp
@@ -21,7 +21,7 @@ namespace util {
         );
     }
 
-    std::filesystem::path NucleusPaths::deTilde(std::string_view s) const {
+    std::filesystem::path NucleusPaths::deTilde(std::string_view s) {
         std::shared_lock guard{_mutex};
         // converts a string-form path into an OS path
         // replicates GG-Java
diff --git a/nucleus/src/util/nucleus_paths.hpp b/nucleus/src/util/nucleus_paths.hpp
index 4b30d29..1f829de 100644
--- a/nucleus/src/util/nucleus_paths.hpp
+++ b/nucleus/src/util/nucleus_paths.hpp
@@ -48,7 +48,7 @@ namespace util {
 
         static void createPath(const std::filesystem::path &path);
 
-        std::filesystem::path deTilde(std::string_view s) const;
+        static std::filesystem::path deTilde(std::string_view s) ;
         static std::filesystem::path resolve(
             const std::filesystem::path &first, const std::filesystem::path &second
         );
@@ -235,7 +235,7 @@ namespace util {
         [[nodiscard]] std::filesystem::path getLoaderPath();
         [[nodiscard]] std::filesystem::path getBinDir();
 
-        [[nodiscard]] std::filesystem::path workPath(const std::string_view serviceName) {
+        [[nodiscard]] std::filesystem::path workPath(const std::string_view serviceName) const {
             std::filesystem::path path{workPath() / serviceName};
             createPath(path);
             _permissions.setServiceWorkPathPermission(path);
diff --git a/nucleus/tests/test_ggroot.hpp b/nucleus/tests/test_ggroot.hpp
index c0f789a..ebb057c 100644
--- a/nucleus/tests/test_ggroot.hpp
+++ b/nucleus/tests/test_ggroot.hpp
@@ -9,25 +9,24 @@ namespace test {
 
     class GGRoot : public TempDir {
     protected:
-        void threadRunner() {
+        static void threadRunner() {
             int res = kernel.launch();
             result.store(res);
             finished.store(true);
         }
 
     public:
-        data::Global global;
-        data::SysProperties sysProps;
-        std::vector<std::string> args;
-        lifecycle::Kernel kernel;
+        data::Global global{};
+        data::SysProperties sysProps{};
+        std::vector<std::string> args{};
+        lifecycle::Kernel kernel{};
         std::thread kernelThread;
         std::atomic_int result;
         std::atomic_bool finished;
 
-        GGRoot() : kernel(global) {
-        }
+        GGRoot() : kernel(global) = default;
 
-        void preLaunch() {
+        static void preLaunch() {
             lifecycle::CommandLine commandLine{global, kernel};
             commandLine.parseArgs(args);
             kernel.preLaunch(commandLine);
diff --git a/nucleus/tests/test_tools.hpp b/nucleus/tests/test_tools.hpp
index 8485ea7..6274ea6 100644
--- a/nucleus/tests/test_tools.hpp
+++ b/nucleus/tests/test_tools.hpp
@@ -11,7 +11,7 @@ namespace test {
         std::filesystem::path _tempDir;
 
     private:
-        std::filesystem::path genPath() {
+        static std::filesystem::path genPath() {
             auto tempdir = std::filesystem::temp_directory_path();
             std::string prefix = "gg-lite-test-";
             std::random_device rd;
diff --git a/plugin_api/include/cpp_api.hpp b/plugin_api/include/cpp_api.hpp
index bf959f6..3c1dec4 100644
--- a/plugin_api/include/cpp_api.hpp
+++ b/plugin_api/include/cpp_api.hpp
@@ -236,10 +236,10 @@ namespace ggapi {
         }
 
         [[nodiscard]] Subscription subscribeToTopic(StringOrd topic, topicCallback_t callback);
-        [[nodiscard]] Scope sendToTopicAsync(
+        [[nodiscard]] static Scope sendToTopicAsync(
             StringOrd topic, Struct message, topicCallback_t result, int32_t timeout = -1
         );
-        [[nodiscard]] Scope sendToListenerAsync(
+        [[nodiscard]] static Scope sendToListenerAsync(
             Subscription listener, Struct message, topicCallback_t result, int32_t timeout = -1
         );
         [[nodiscard]] static Struct sendToTopic(
diff --git a/plugins/example_layered_plugin/main.cpp b/plugins/example_layered_plugin/main.cpp
index 83b963f..a63c75d 100644
--- a/plugins/example_layered_plugin/main.cpp
+++ b/plugins/example_layered_plugin/main.cpp
@@ -13,7 +13,7 @@ public:
 
 class LayeredPlugin : public ggapi::Plugin {
     mutable std::mutex _mutex;
-    std::map<uint32_t, std::unique_ptr<DelegatePlugin>> _delegates;
+    std::map<uint32_t, std::unique_ptr<DelegatePlugin>> _delegates{};
 
 public:
     void onDiscover(ggapi::Struct data) override;
@@ -23,7 +23,7 @@ public:
         return layeredPlugin;
     }
 
-    DelegatePlugin &getDelegate(ggapi::Scope scope) {
+    static DelegatePlugin &getDelegate(ggapi::Scope scope) {
         std::unique_lock guard{_mutex};
         return *_delegates[scope.getHandleId()];
     }
@@ -48,11 +48,11 @@ void greengrass_delegate_lifecycle(
     LayeredPlugin::getSelf().getDelegate(moduleHandle).lifecycle(moduleHandle, phase, data);
 }
 
-void DelegatePlugin::onStart(ggapi::Struct data) {
+static void DelegatePlugin::onStart(ggapi::Struct data) {
     std::cout << "Running getDelegate start... " << std::endl;
 }
 
-void LayeredPlugin::onDiscover(ggapi::Struct data) {
+static void LayeredPlugin::onDiscover(ggapi::Struct data) {
     std::cout << "Layered Plugin: Running lifecycle discovery" << std::endl;
     std::unique_lock guard{_mutex};
     ggapi::ObjHandle nestedPlugin =
